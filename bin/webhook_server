#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
Usage:
    webhook_server --port <port> [options]

Arguments:
    <port> -- The port to run the server on.

Options:
    --logging (debug | info | error)
    --log_file <log_file> also log to a file
"""

import BaseHTTPServer
import hashlib
import hmac
import json
import logging
import os

from docopt import docopt

from gitenberg_autoupdate import __version__, queue, util

GITHUB_WEBHOOK_SECRET = os.environ['GITHUB_WEBHOOK_SECRET']

def _verify_signature(body, signature):
  signature_check = 'sha1=' + hmac.new(GITHUB_WEBHOOK_SECRET, body, hashlib.sha1).hexdigest()
  return not hmac.compare_digest(signature, signature_check)

class RequestHandler(BaseHTTPServer.BaseHTTPRequestHandler):
  def do_GET(self):
    if self.path != '/health':
      self.send_error(404)
      return

    # Claim we're alive and healthy if we're responding to this GET.
    self.send_response(200)
    self.end_headers()

  def do_POST(self):
    if self.path != '/payload':
      self.send_error(404)
      return

    if 'Content-Length' not in self.headers:
      self.send_error(400)
      return
    if 'X-Hub-Signature' not in self.headers:
      self.send_error(400)
      return

    content_length = int(self.headers['Content-Length'])
    payload_string = self.rfile.read(content_length)
    if _verify_signature(payload_string, self.headers['X-Hub-Signature']):
      self.send_error(500)
      return

    try:
      payload = json.loads(payload_string)
    except ValueError:
      self.send_error(400)
      return

    repo = payload[u'repository'][u'full_name']
    logging.info('Sending message for %s' % repo)
    queue.queue_resource().send_message(MessageBody=repo)

    self.send_response(200)
    self.end_headers()

if __name__ == '__main__':
  arguments = docopt(__doc__, version=__version__)

  util.setup_logging(arguments)

  port = int(arguments.get('<port>', '80'))

  server = BaseHTTPServer.HTTPServer(('0.0.0.0', port), RequestHandler)
  try:
    server.serve_forever()
  except KeyboardInterrupt:
    pass
  server.server_close()
